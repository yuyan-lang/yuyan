「： 寻观标准库之书。

寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之总集之书。




寻观豫言编译器之编译数据之编译配置之全局配置之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。


寻观优化统计信息之书。
寻观树组未使用函数消除之书。
寻观树组函数参数优化之书。
寻观树组其他优化方法之书。
寻观树组常量展开之书。
寻观树组函数内联之书。
寻观树组续延函数内联之书。
寻观树组栈分配优化之书。



优化调试信息打印乃化（化有而字符串）而有也。
优化调试信息打印者会字符串函数而
    若（读引用于「打印优化调试信息」）则
        （非常粗略调试打印行于字符串函数）
    否则元也。

优化名未使用函数消除即『未使用函数消除』也。
优化名函数参数优化即『函数参数优化』也。
优化名未使用式消除即『未使用式消除』也。
优化名常量展开即『常量展开』也。
优化名函数内联即『函数内联』也。
优化名续延函数内联即『续延函数内联』也。
优化名栈分配优化即『栈分配优化』也。


一轮优化循环乃化整数「：当前轮序数：」而
            化（字符串列）「：当前所要执行的优化名：」而
            化抽象语法树组「：输入式：」而
            抽象语法树组也。
一轮优化循环者会当前轮数而会执行优化名而会开始式而
    虑「

        优化计次数乃引用类于整数列也。
        优化计次数者新引用于【】也。
        执行单一优化乃化抽象语法树组而化字符串而抽象语法树组也。
        执行单一优化者会式而会优化名而
            虑原先计次者（读引用于「当前优化数量」）而
            虑后式者
                若（存在吗于（「串相等」于「优化名」）于（读引用于跳过编译优化诸名称））
                    则式
                    否则 （抽象语法树组也鉴「优化名」而
                            有『未使用函数消除』则（「树组未使用函数消除」于式）
                            或有『未使用式消除』则（「树组未使用表达式消除」于式）
                            或有『常量展开』则（「树组常量展开」于式）
                            或有『函数内联』则（「树组函数内联」于式）
                            或有『函数参数优化』则（「树组函数参数优化」于式）
                            或有『续延函数内联』则（「树组函数续延函数内联」于式）
                            或有『栈分配优化』则（「树组栈分配优化顶层」于式）
                            或有「其他」则（发生事故于『不认识的优化名：』附（优化名））
                        ）而
            虑后计次者（读引用于「当前优化数量」）而
            虑无者（写引用于（优化计次数）于（（读引用于（优化计次数））接【后计次减原先计次】））而
            「： 虑无者「优化调试信息打印」于（会无而「优化名」附『后：』附（抽象语法友好表示于零于后式））而 ：」
            后式
            也。

        进行一轮优化乃化抽象语法树组而化字符串列而抽象语法树组也。
        进行一轮优化者循进行一轮优化以会式而会余下优化名而
            鉴「余下优化名」而
                有【】则式
                或有「当前优化名」衔「剩余优化名」则
                    （
                        虑无者「编译调试打印行」于『tree_opt_debug_progress』于（
                            会无而『即将进行』附「当前优化名」附『优化』
                        ）而
                        虑无者「编译调试打印行」于『tree_opt_debug_print_trees』于（
                            会无而『即将进行』附「当前优化名」附『优化，树组是』附（抽象语法树组友好表示于零于式）
                        ）而
                        「进行一轮优化」于（执行单一优化于式于「当前优化名」）于「剩余优化名」
                    ）也。

        写引用于「当前优化数量」于零。
        最终结果者进行一轮优化于开始式于执行优化名也。
        「： 总优化数量者读引用于「当前优化数量」也。 ：」

        （粗略调试打印行于（会无而
                『| 第』附（整数表示于当前轮数）附『轮优化共计』附（整数表示于（读引用于当前优化数量））附『处，其中』附
                （以『，』合并（态射二于（会名而会次数而
                    名附（整数表示于次数）附『次』
                ）于执行优化名于（读引用于优化计次数）））附『。』））。

        最终结果
    」也。 

半个优化循环乃化整数而化抽象语法树组而抽象语法树组也。
半个优化循环者会当前轮数而会式而
    若（存在吗于（「串相等」于『tree-half-opt』）于（读引用于跳过编译优化诸名称））则式否则（
        「一轮优化循环」于当前轮数于【
                「： 「优化名续延函数内联」
                ，「优化名栈分配优化」
                ，「优化名未使用函数消除」 ：」
        】于式
    ）
    也。 



一个优化循环乃化整数而化抽象语法树组而抽象语法树组也。
一个优化循环者会当前轮数而会式而
    「一轮优化循环」于当前轮数于（【
            「优化名常量展开」
            ，「优化名未使用式消除」
            ，「优化名函数内联」
        】接【
            「： 「优化名函数参数优化」 ：」
        】接【
            「优化名未使用函数消除」
        】）于式也。 

闭包后优化乃化整数而化整数而化抽象语法树组而抽象语法树组也。
闭包后优化者循闭包后优化以会当前轮数而会总轮数而会式而
    虑结果者（若当前轮数等于总轮数
            则「半个优化循环」于当前轮数于式
            否则「一个优化循环」于当前轮数于式）而
    若（「或者」于（当前轮数等于总轮数）于（当前轮数大于总轮数））
        则（结果）
        否则（闭包后优化于（当前轮数加一）于总轮数于结果）也。


闭包后所有优化步骤乃化抽象语法树组而抽象语法树组也。
闭包后所有优化步骤者会式而
            （若
    （（读引用于执行优化总轮数）等于零）
    则（式）
    否则（
        「闭包后优化」于一于（读引用于执行优化总轮数）于式
    ））
    也。
 ：」
