
寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之总集之书。

。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。





寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译步骤之总体过程之编译过程工具之书。

「： 寻观代码生成工具之书。 ：」
寻观直接代码生成之书。
寻观豫言编译器之编译数据之编译配置之全局配置之书。
寻观豫言编译器之编译步骤之代码生成之工具之工具之书。
「： 寻观续延转换代码生成工具之书。 ：」


尾调用返回乃化字符串而字符串也。
尾调用返回者会名而
        『ret i64* %"』附名附『"』也。

「：给定字符串，条件输出可以直接插入源码的字符串：」
调试写乃化（化有而字符串）而字符串也。
调试写者会串而若（读引用于（字节码打印调试信息））
       则 『// /* 』附（串查找替换于（串于元）于『「：换行：」』于『「：「：：」换行：」』）附『 */「：换行：」』否则『』也。



代码生成乃
         化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
代码生成者循「代码生成」以会已有自由变量而会式而
    虑「

        递归同变量者代码生成于已有自由变量也。
        递归者代码生成也。
        保留字段者下个字符序数于『_保留_』也。

        解绑乃承甲而化表达式而化（化字符串而化表达式而甲）而甲也。
        解绑者会式而会继续而
            虑无者编译调试打印行于『codegen_perf』于（会无而『正在解绑』）而
            虑名及后式者（解构抽象不重复名称于（更新可能绑定名特殊变换于「标识符转义」于式）于已有自由变量）而「：强制更新名称：」
            虑无者编译调试打印行于『codegen_perf』于（会无而『解绑完成』）而
            继续于（名及后式中零）于（名及后式中一）也。


        「读名」者「读取直接变量」也。


        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于「当前」衔「下个」衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（拉姆达抽象续延于「续延名」）于「单绑定」衔【】）则
                                        （
                                           虑函数内容者（
                                                    解绑于单绑定于（会参数名而会函体而
                                                        （
                                                            （包裹函数体于【 参数名】于（
                                                                「递归」于【 参数名】于函体
                                                            ））
                                                        ）
                                            ））而
                                            「： （调试写于（会无而（表达式表示于当前）））附 ：」
                                            『let 』附后名附『 = 』附（函数内容）附『「：换行：」』附
                                            （递归于（已有自由变量接【后名】）于后下个） 
                                        ）
                                    或有（式节点于（函数调用续延于「续延名」）于「参数」衔【】）则
                                        （
                                            虑函数名者续延名而
                                            虑参数名者读名于参数而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            「： 『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*换行』附 ：」
                                            （『let 』附后名附『 = () => { return 』附函数名附（获取普通参数签名于【参数名】）附『; };「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ）
                                    或有「其他」则
                                        （
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于后名于当前）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ））
                    ））
                
                
                或有（式节点于（爻分支节点）于「爻式」衔「阳式」衔「阴式」衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        『if (』附（爻式名）附『) {「：换行：」』附
                        （递归同变量于阳式）附『「：换行：」』附
                        『} else {「：换行：」』附
                        （递归同变量于阴式）附
                        『}「：换行：」』
                    ）

                
                或有「其他」则
                    （
                        虑返回名者下个字符序数于『结果』而
                        （「直接代码生成」于返回名于「其他」）
                        「： 附（续延返回于『』附返回名附『』） ：」
                        附（『return 』附返回名附『「：换行：」』）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        编译调试打印行于『codegen_result』于（会无而『代码生成完成，长度：』附（整数表示于（字节长度于转换结果）））。
        转换结果
」
也。


单函数代码生成乃化（字符串合爻合表达式）「：待变换的式子：」
         而字符串「：生成的代码：」也。
单函数代码生成者会名及式而
    虑函数名者名及式中零而
    虑式者名及式中二而
    虑结果者（字符串也
        鉴式而
            有（式节点于（拉姆达抽象于「拉形」）于「单绑定」衔【】）则
                    解构抽象并继续于「单绑定」于（会参数名而会拉体而
                        （
                        『let 』附（函数名）附『 = (』附参数名附『) => {「：换行：」』附
                                （「代码生成」于【参数名】于拉体）附
                        『};』
                    ）
                ）
            或有「其他」则发生事故于『期待拉姆达抽象，却得到了』附（表达式表示于式）
    ）而
    结果
                                        也。
「： 写引用于代码生成引用于代码生成。 ：」
癸本单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化（字符串合爻合表达式）列而「：待变换式：」
             字符串「：编译模块的源码：」也。
癸本单个文件代码生成顶层者会先前模块路径名而会当前路径而会式而
    虑模块内部名者（当前路径转全局函数名于当前路径）附『_内部实现』而
    『let 』附模块内部名附『 = (() => {「：换行：」』附
    （以『「：换行：」』合并（态射于（单函数代码生成）于式））附『「：换行：」』附
    『return {』附
    （以『,「：换行：」』合并（打表态射于式于（会名及剩余而（名及剩余中零）附『: 』附（名及剩余中零））））附『};』附『「：换行：」』附
    『})();「：换行：」』附
    （以『』合并（滤态射于（会甲而甲）于（打表态射于式于（会名及可见性及式而
        若（名及可见性及式中一）
        则（可有（『let 』附（名及可见性及式中零）附『 = 』附（模块内部名）附『.』附（名及可见性及式中零）附『;「：换行：」』））
        否则「可无」
    ））））
    也。 

「：上个是单独文件编译，我们未来版本可能会用到，不过因为性能考虑，我们优先使用整体编译：」
癸本可执行文件代码生成顶层乃
             化（字符串合爻合表达式）列而字符串「：编译模块的源码：」也。
癸本可执行文件代码生成顶层者会式而
    虑输出引用者新引用于【】而
    虑模块标准名者下个字符序数于『总体模块』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者下个字符序数于『整体函数』而
    虑无者（有也（若（（长度于式）大于一）则发生事故于『343代』否则元））而
    虑无者（写出于
        『let 』附本次函数名附『"(){「：换行：」』附
        （「代码生成」于【】于（第N个于零于式）中二）附
        『}』
        ）而
    「：写全局的模块：」
    虑无者（写出于
        『let entryMain = () => {「：换行：」』附
        『』附本次函数名附『()「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        『};「：换行：」』附
        『entryMain();』
        ）而
    虑最终输出源码者『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。
    