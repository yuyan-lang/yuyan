
寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之总集之书。

。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。




寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。
寻观豫言编译器之编译步骤之总体过程之编译过程工具之书。

寻观代码生成工具之书。
寻观直接代码生成之书。
寻观豫言编译器之编译数据之编译配置之全局配置之书。

寻观续延转换代码生成工具之书。
寻观豫言编译器之编译步骤之代码生成之工具之工具之书。

尾调用返回乃化字符串而字符串也。
尾调用返回者会名而
        『ret i64* %"』附名附『"』也。


代码生成解绑乃承甲而化字符串列而化表达式而化（化字符串而化表达式而甲）而甲也。
代码生成解绑者会已有自由变量而会式而会继续而
    虑无者编译调试打印行于『codegen_perf』于（会无而『正在解绑』）而
    虑名及后式者（解构抽象不重复名称于（更新可能绑定名于式）于已有自由变量）而「：强制更新名称：」
    虑无者编译调试打印行于『codegen_perf』于（会无而『解绑完成』）而
    继续于（名及后式中零）于（名及后式中一）也。

代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。
        保留字段者下个字符序数于『_保留_』也。

        解绑者代码生成解绑于已有自由变量也。



        「读名」者「读取直接变量」也。


        编译调试打印行于『codegen_result』于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于「当前」衔「下个」衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（函数调用三参数）于「函数」衔「参数一」衔「参数二」衔「参数三」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数一名者读名于参数一而
                                            虑参数二名者读名于参数二而
                                            虑参数三名者读名于参数三而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*「：换行：」』附
                                            （『%"』附后名附『" = musttail call 』附默认调用规范附『 i64* %"函数指针』附（保留字段）附『"』附（获取普通参数签名于【参数一名，参数二名，参数三名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ）
                                    或有（式节点于（拉姆达抽象续延）于「拉参」衔【】）则
                                        （
                                            虑函数名者后名而
                                            虑调用次数及后后下个者函数调用更改标注顶层于函数名于后下个而
                                            虑调用次数者调用次数及后后下个中零而
                                            虑后后下个者调用次数及后后下个中一而
                                            （调试写于（会无而『拉姆达抽象续延：』附函数名））附
                                            （递归于已有自由变量于后后下个）附（
                                                解绑于拉参于（会参数名而会函数体而
                                                    （调试写于（会无而『拉姆达抽象续延：』附函数名））附
                                                    『"』附函数名附『_进入标签":「：换行：」』附
                                                    『%"』附参数名附『" = phi i64* 』附（
                                                        以『, 』合并（
                                                            打表于调用次数于（会当前序数而
                                                                『[ %"』附函数名附『_参数_』附（整数表示于当前序数）附『" , %"』附函数名附『_参数标签_』附（整数表示于当前序数）附『" ]』
                                                            ）
                                                        ）
                                                    ）附『「：换行：」』附
                                                    （递归于（已有自由变量接【参数名】）于函数体）
                                                ）
                                            ）
                                        ）
                                    或有（式节点于（函数调用续延代码生成于「当前序数」）于「函数」衔「参数」衔【】）则
                                        （
                                            若（表达式是返回自由变量于下个）
                                            则（
                                                虑函数名者读名于函数而
                                                虑参数名者读名于参数而
                                                （调试写于（会无而（表达式表示于当前）））附
                                                『br label %"』附函数名附『_参数标签_』附（整数表示于当前序数）附『"「：换行：」』附
                                                『"』附函数名附『_参数标签_』附（整数表示于当前序数）附『":「：换行：」』附
                                                『%"』附函数名附『_参数_』附（整数表示于当前序数）附『" = bitcast i64* %"』附参数名附『" to i64*「：换行：」』附
                                                『br label %"』附函数名附『_进入标签"』附『「：换行：」』
                                            ）否则（
                                                发生事故于『代码生成，函数续延调用后不是直接返回，而是』附（表达式表示于下个）
                                            ）
                                        ）
                                    或有「其他」则
                                        （
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于写出于后名于当前）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ））
                    ））
                
                或有（式节点于（爻分支节点）于「爻式」衔「阳式」衔「阴式」衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        『%"』附保留字段附『爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                        『%"』附保留字段附『爻为真" = icmp ne i1 %"』附保留字段附『爻", 0「：换行：」』附
                        『br i1 %"』附保留字段附『爻为真", label %"』附保留字段附『真", label %"』附保留字段附『假"「：换行：」』附
                        『"』附保留字段附『真":「：换行：」』附
                        （递归同变量于阳式）附『「：换行：」』附
                        『"』附保留字段附『假":「：换行：」』附
                        （递归同变量于阴式）
                    ）

                或有（式节点于模式匹配于「分析式」衔「分支们」）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析名者读名于分析式而
                            （虑「
                                处理后分支们及默认分支者模式匹配分支分析于「分支们」也。

                                处理后分支们者处理后分支们及默认分支中零也。
                                默认分支者处理后分支们及默认分支中一也。
                                
                                默认分支代码者（字符串也鉴默认分支而
                                    有（式节点于（变量模式匹配分支）于「结果」衔【】）则
                                        （
                                            （递归同变量于（式替换于（自由变量于分析名）于结果））
                                        ）
                                    或有「其他」则（
                                        发生事故于『默认分支格式错误』附（表达式表示于默认分支）
                                    ））也。


                                处理字符串分支乃化整数而化表达式列而字符串也。
                                处理字符串分支者循处理字符串分支以会数而会剩余分支们而
                                    鉴剩余分支们而
                                        有【】则（
                                            『"分支』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            默认分支代码
                                        ）
                                        或有「当前」衔「剩余」则（
                                            虑无者编译调试打印行于『codegen_result』于（会无而『处理字符串分支：剩余：』附（整数表示于（长度于剩余））附（表达式表示于当前））而
                                            『"分支』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            （鉴当前而
                                                有（式节点于（常量模式匹配分支）于（式节点于（字符串节点于「串」）于【】）衔「结果」衔【】）则
                                                    （
                                                        虑无者编译调试打印行于『codegen_result』于（会无而『进入字符串188』）而
                                                        虑串名者下个字符序数于『模式匹配字符串』而
                                                        虑无者编译调试打印行于『codegen_result』于（会无而『进入字符串189』）而
                                                        虑无者写出于（字符串声明于串名于串）而
                                                        虑无者编译调试打印行于『codegen_result』于（会无而『进入字符串192』）而
                                                        虑无者「添加外部调用」于『yyStringEq』于（二）而
                                                        虑无者编译调试打印行于『codegen_result』于（会无而『进入字符串194』）而
                                                        虑调试串者（调试写于（会无而（串）））而
                                                        虑无者编译调试打印行于『codegen_result』于（会无而『进入字符串196』）而
                                                        （
                                                            调试串附
                                                        『%"比较值』附（整数表示于数）附『』附保留字段附『" = bitcast 』附（字符串声明类型于串）附『* @"』附（串名）附『" to i64*「：换行：」』附
                                                        （『%"返回值值』附（整数表示于数）附『』附保留字段附『" = call i64* @"yyStringEq"(i64* %"比较值』附（整数表示于数）附『』附保留字段附『", i64* %"』附分析名附『")「：换行：」』）附
                                                        『%"条件』附（整数表示于数）附『』附保留字段附『" = ptrtoint i64* %"返回值值』附（整数表示于数）附『』附保留字段附『" to i1「：换行：」』附
                                                        『br i1 %"条件』附（整数表示于数）附『』附保留字段附『", label %"进入』附（整数表示于数）附『』附保留字段附『", label %"分支』附（整数表示于（数加一））附『』附保留字段附『"「：换行：」』
                                                        ）
                                                    ）
                                                或有「其他」则（发生事故于『生249：期待字符串模式匹配分支，却得到了』附（表达式表示于当前））
                                            ）附『「：换行：」』附
                                            『"进入』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            （鉴当前而
                                                有（式节点于（常量模式匹配分支）于「常量」衔「结果」衔【】）则
                                                    （
                                                        递归同变量于结果
                                                    ）
                                                或有「其他」则（发生事故于『生249：期待字符串模式匹配分支，却得到了』附（表达式表示于当前））
                                            ）附『「：换行：」』附
                                            （处理字符串分支于（数加一） 于剩余）
                                        ）也。

                                处理整数常数分支乃化表达式列而字符串也。
                                处理整数常数分支者会整数分支们而
                                    以『「：换行：」』合并（
                                        打表态射于整数分支们于（会分支而
                                            鉴分支而
                                                有（式节点于（常量模式匹配分支）于（式节点于（整数节点于「数」）于【】）衔「结果」衔【】）则
                                                    『"进入』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                                    （递归同变量于结果）
                                                或有「其他」则（发生事故于『生177：期待整数模式匹配分支，却得到了』附（表达式表示于分支））
                                        ）
                                    ）也。

                                处理构造器常数分支乃化表达式列而字符串也。
                                处理构造器常数分支者会构造器分支们而
                                    以『「：换行：」』合并（
                                        打表态射于构造器分支们于（会分支而
                                            鉴分支而
                                                有（式节点于（唯一构造器模式匹配分支于「序数」）于「结果」衔【】）则
                                                    『"进入』附（整数表示于序数）附『』附保留字段附『":「：换行：」』附
                                                            （解绑于结果于（会绑定名而会后续而
                                                                虑当前保留字段者下个字符序数于保留字段而
                                                                『%"构造器数组』附当前保留字段附『" = bitcast i64* %"』附分析名附『" to i64**「：换行：」』附
                                                                『%"构造器参数数组』附当前保留字段附『" = getelementptr i64*, i64** %"构造器数组』附当前保留字段附『", i64 1「：换行：」』附
                                                                『%"』附绑定名附『" = bitcast i64** %"构造器参数数组』附当前保留字段附『" to i64*「：换行：」』附
                                                                （递归于（已有自由变量接【绑定名】）于后续）
                                                            ））
                                                或有「其他」则（发生事故于『生177：期待构造器模式匹配分支，却得到了』附（表达式表示于分支））
                                        ）
                                    ）也。

                                字符串也
                                鉴处理后分支们而
                                    有【】则
                                        （
                                            默认分支代码
                                        ）
                                    或有（式节点于（常量模式匹配分支）于「判断常量」衔「判断结果」衔【】）衔「其余分支」则
                                        （
                                            鉴「判断常量」而
                                                有（式节点于（整数节点于「判断数」）于【】）则
                                                    （
                                                        『%"当前分析数』附保留字段附『" = ptrtoint i64* %"』附分析名附『" to i64「：换行：」』附
                                                        『switch i64 %"当前分析数』附保留字段附『", label %"默认分支』附保留字段附『" [』附
                                                            （
                                                               以『』合并（ 打表态射于处理后分支们于（会分支而
                                                                    鉴分支而
                                                                        有（式节点于（常量模式匹配分支）于（式节点于（整数节点于「数」）于【】）衔「结果」衔【】）则
                                                                            『 i64 』附（整数表示于数）附『, label %"进入』附（整数表示于数）附保留字段附『"』
                                                                        或有「其他」则
                                                                            （发生事故于『291期待整数分支』）
                                                                ））
                                                            ）附『]「：换行：」』附
                                                            『"默认分支』附保留字段附『":「：换行：」』附
                                                            默认分支代码附
                                                            （处理整数常数分支于处理后分支们）附『「：换行：」』
                                                    ）
                                                或有（式节点于（字符串节点于「串」）于【】）则
                                                    （
                                                        『br label %"分支0』附保留字段附『"「：换行：」』附
                                                       （处理字符串分支于零于处理后分支们）
                                                    ）
                                                或有「其他」则（发生事故于『不支持的常量模式匹配分支：』附（表达式表示于「判断常量」））
                                        ）
                                    或有（式节点于（唯一构造器模式匹配分支于「判断序数」）于「【判断结果」衔【】）衔「其余分支」则
                                        （
                                            『%"当前构造器分析数』附保留字段附『" = load i64, i64* %"』附分析名附『"「：换行：」』附
                                            『switch i64 %"当前构造器分析数』附保留字段附『", label %"默认分支』附保留字段附『" [』附
                                                （
                                                    以『』合并（ 打表态射于处理后分支们于（会分支而
                                                        鉴分支而
                                                            有（（式节点于（唯一构造器模式匹配分支于「序数」）于「结果」衔【】））则
                                                                『 i64 』附（整数表示于序数）附『, label %"进入』附（整数表示于序数）附保留字段附『" 』
                                                            或有「其他」则
                                                                （发生事故于『291期待构造器分支』）
                                                    ））
                                                ）附『]「：换行：」』附
                                                『"默认分支』附保留字段附『":「：换行：」』附
                                                默认分支代码附
                                                （处理构造器常数分支于处理后分支们）附『「：换行：」』
                                            
                                        ）
                                    或有「其他」则发生事故于『期待处理后分支尾常量或者唯一构造式』
                            」）
                    ）
                「： 或有（式节点于（续延调用节点）于「续参」衔【】）则（
                    解绑于续参于（会续延名而会续参体而
                        『%"』附（续延名）附『" = bitcast i64* %"』附续延函数名附『" to i64*「：换行：」』附
                        （递归于（已有自由变量接【续延名】）于续参体）
                    ）
                ） ：」
                或有「其他」则
                    （
                        虑返回名者下个字符序数于『结果』而
                        （「直接代码生成」于写出于返回名于「其他」）
                        「： 附（续延返回于『』附返回名附『』） ：」
                        附（『ret i64* %"』附返回名附『"「：换行：」』）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        编译调试打印行于『codegen_result』于（会无而『代码生成完成，长度：』附（整数表示于（字节长度于转换结果）））。
        转换结果
」
也。

单函数代码生成乃化（化字符串而有）「：写全局文件：」
        而化字符串「：当前路径：」
         而化（字符串合表达式）「：待变换的式子：」
         而有「：生成的代码：」也。
单函数代码生成者会写出而会路径而会名及式而
    虑函数名者名及式中零而
    虑式者名及式中一而
    虑解绑者代码生成解绑于【】而
    虑结果者（字符串也
        鉴式而
            有（式节点于（拉姆达抽象三参数）于「三绑定」衔【】）则
                    解绑于三绑定于（会闭包名而会双绑定而
                        解绑于双绑定于（会参数名而会单绑定而
                            解绑于单绑定于（会续延函数名而会函体而
                                （
                                    （包裹函数体于（「串相等」于「函数名」于（当前路径转全局函数名于路径））
                                              于函数名于【闭包名， 参数名，续延函数名】于（
                                        「代码生成」于写出于【闭包名， 参数名，续延函数名】于函体
                                    ））
                                ）
                        ）
                    ）
                ）
            或有「其他」则发生事故于『期待拉姆达抽象三参数，却得到了』附（表达式表示于式）
    ）而
    写出于结果
                                        也。

「： 写引用于代码生成引用于代码生成。 ：」
低级虚拟机单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化（字符串合表达式）列而「：待变换式：」
             字符串「：编译模块的源码：」也。
低级虚拟机单个文件代码生成顶层者会先前模块路径名而会当前路径而会式而
    虑输出引用者新引用于【】而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑无者（写出于
        『@"』附（当前路径转模块全局名于当前路径）附『" = global i64* null「：换行：」』
        「： 附 ：」
        「： 『define 』附默认调用规范附『 i64* @"』附（当前路径转全局函数名于当前路径）附『"(i64* %"保留名_目的是tailcall_1", i64* %"保留名_目的是tailcall_2", i64* %"保留名_目的是tailcall_3"){「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』 ：」
        ）而
    虑无者（态射授以（字符串合表达式）授以有于（单函数代码生成于写出于当前路径）于式）而
    虑无者编译调试打印行于『codegen_result』于（会无而『主要代码生成完成！』）而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    虑无者（态射于（会路径而写出于
                    （
                        「： 虑先前全局名者（读取代码生成信息于路径）中零而 ：」
                        （调试写于（会无而路径））附『@"』附（当前路径转模块全局名于路径）附『" = external global i64*』）
                ）于先前模块路径名）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    虑无者编译调试打印行于『codegen_result』于（会无而『全部代码生成完成！』）而
    最终输出源码
    也。 

    
「：上个是单独文件编译，我们未来版本可能会用到，不过因为性能考虑，我们优先使用整体编译：」
低级虚拟机可执行文件代码生成顶层乃化字符串而
             化（字符串合表达式）列而字符串「：编译模块的源码：」也。
低级虚拟机可执行文件代码生成顶层者会当前路径而会式而
    虑输出引用者新引用于【】而
    「： 虑模块标准名者下个字符序数于『总体模块』而 ：」
    「： 虑全局名者下个字符序数于模块标准名附『_模块』而 ：」
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    「： 虑本次函数名者下个字符序数于『整体函数』而 ：」
    虑无者（写出于
        『@"』附（当前路径转模块全局名于当前路径）附『" = global i64* null「：换行：」』
        「： 附
        『define 』附默认调用规范附『 i64* @"』附本次函数名附『"(i64* %"保留名_目的是tailcall_1", i64* %"保留名_目的是tailcall_2", i64* %"保留名_目的是tailcall_3"){「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』 ：」
        ）而
    虑无者（态射授以（字符串合表达式）授以有于（单函数代码生成于写出于当前路径）于式）而
    虑无者「添加外部调用」于『全局异常处理器』于三而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    「：写全局的模块：」
    虑无者（写出于
        『define 』附默认调用规范附『 i64* @"内部全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层"){「：换行：」』附
        『%"默认值" = call i64* @"全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层")「：换行：」』附
        『ret i64* null「：换行：」』附
        『}「：换行：」』附
        『define i64* @"entryMain"(){「：换行：」』附
        『%"全局返回值" = call 』附默认调用规范附『 i64* @"』附（当前路径转全局函数名于当前路径）附『"(i64* null, i64* null, i64* null)「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        （尾调用返回于『全局返回值』）附『「：换行：」』附
        『}』
        ）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。