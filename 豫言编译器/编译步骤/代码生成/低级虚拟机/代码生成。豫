
寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之总集之书。

。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。





寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译步骤之总体过程之编译过程工具之书。

寻观代码生成工具之书。
寻观直接代码生成之书。

寻观续延转换代码生成工具之书。
寻观豫言编译器之编译步骤之代码生成之工具之工具之书。

尾调用返回乃化字符串而字符串也。
尾调用返回者会名而
        『ret i64* %"』附名附『"』也。


代码生成解绑乃承甲而化表达式而化（化字符串而化表达式而甲）而甲也。
代码生成解绑者会式而会继续而
    虑无者编译调试打印行于『codegen_perf』于（会无而『正在解绑』）而
    虑名及后式者（解构抽象于（更新可能绑定名特殊变换于「标识符转义」于式））而「：强制更新名称：」
    虑无者编译调试打印行于『codegen_perf』于（会无而『解绑完成』）而
    继续于（名及后式中零）于（名及后式中一）也。

代码生成乃化（化字符串而有）「：写全局文件：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
代码生成者循「代码生成」以会写出而会式而
    虑「

        递归者代码生成于写出也。
        保留字段者下个字符序数于『_保留_』也。

        解绑者代码生成解绑也。



        「读名」者「读取直接变量」也。


        编译调试打印行于『codegen_result』于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于「当前」衔「下个」衔【】）则
                    （解绑于下个于（会后名而会后下个而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于写出于后名于当前）附
                                            （递归于后下个）
                                        
                    ））
                或有（式节点于「顺序执行节点」于「当前」衔「下个」衔【】）则
                    （（
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于写出于保留字段于当前）附
                                            （递归于下个）
                    ））
                或有（式节点于（函数调用续延无绑定于「续延名」）于【】）则
                    （
                        『br label %"』附续延名附『_进入标签"』附『「：换行：」』 
                    ）
                或有（式节点于（爻分支节点）于「爻式」衔「阳式」衔「阴式」衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        『%"』附保留字段附『爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                        『%"』附保留字段附『爻为真" = icmp ne i1 %"』附保留字段附『爻", 0「：换行：」』附
                        『br i1 %"』附保留字段附『爻为真", label %"』附保留字段附『真", label %"』附保留字段附『假"「：换行：」』附
                        『"』附保留字段附『真":「：换行：」』附
                        （递归于阳式）附『「：换行：」』附
                        『"』附保留字段附『假":「：换行：」』附
                        （递归于阴式）
                    ）
                或有（式节点于「空值节点」于【】）则（
                    『ret i64* null「：换行：」』
                ）
                或有「其他」则
                    （
                        若（「是直接变量」于「其他」）
                        则（
                            『ret i64* %"』附（「读取直接变量」于「其他」）附『"「：换行：」』
                        ）否则（
                            发生事故于『未有代码生成110:』附（表达式表示于式）
                        ）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        编译调试打印行于『codegen_result』于（会无而『代码生成完成，长度：』附（整数表示于（字节长度于转换结果）））。
        转换结果
」
也。

顶层续延代码生成乃化（化字符串而有）「：写全局文件：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
顶层续延代码生成者循「顶层续延代码生成」以会写出而会式而
    虑「
        递归者顶层续延代码生成于写出也。
        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「顺序执行节点」于「当前」衔「下个」衔【】）则
                    （（
                        （鉴当前而
                                    有（式节点于（拉姆达抽象续延无绑定于「续延名」）于「拉参」衔【】）则
                                        （
                                           虑无者编译调试打印行于『codegen_progress』于（会无而『正在生成续延代码，名称度：』附（续延名））而
                                            （（调试写于（会无而『拉姆达抽象续延：』附续延名））附
                                            （递归于下个））附
                                                    （（调试写于（会无而『拉姆达抽象续延无绑定：』附续延名））附
                                                    『"』附续延名附『_进入标签":「：换行：」』附
                                                    （代码生成于「写出」于「拉参」））
                                        ）
                                    或有「其他」则
                                        （
                                           虑无者编译调试打印行于『codegen_progress』于（会无而『正在生成续延后主代码』）而
                                            代码生成于「写出」于式
                                        ））
                    ））
                或有「其他」则
                    （
                        代码生成于「写出」于式
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在顶层代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        转换结果
」
也。



单函数代码生成乃化（化字符串而有）「：写全局文件：」
        而化字符串「：当前路径：」
         而化（字符串合爻合表达式）「：待变换的式子：」
         而有「：生成的代码：」也。
单函数代码生成者会写出而会路径而会名及式而
    虑函数名者名及式中零而
    虑式者名及式中二而
    虑解绑者代码生成解绑而
    虑结果者（字符串也
        鉴式而
            有（式节点于（拉姆达抽象于「拉形」）于「单绑定」衔【】）则
                    解绑于单绑定于（会参数名而会拉体而
                        （
                        虑无者编译调试打印行于『codegen_progress』于（会无而『正在生成函数代码，名称：』附函数名）而
                            （包裹函数体于（名及式中一）
                                        于函数名于【参数名】于（
                                「： 虑内部块引用者新引用授以字符串列于【】而
                                虑内部块写出者（遇字符串者甲而写引用于「内部块引用」于（甲衔（读引用于内部块引用）））而 ：」
                                （「顶层续延代码生成」于写出于拉体）
「： 
                                附（以『「：换行：」』合并（读引用于内部块引用）） ：」
                            ））
                    ）
                ）
            「： 有（式节点于（拉姆达抽象三参数）于「三绑定」衔【】）则
                解绑于三绑定于（会闭包名而会双绑定而
                    解绑于双绑定于（会参数名而会单绑定而
                        解绑于单绑定于（会续延函数名而会函体而
                            （
                                （包裹函数体于（名及式中一）
                                            于函数名于【闭包名， 参数名，续延函数名】于（
                                    「代码生成」于写出于【闭包名， 参数名，续延函数名】于函体
                                ））
                            ）
                    ）
                ）
            ） ：」
            或有「其他」则发生事故于『期待拉姆达抽象，却得到了』附（表达式表示于式）
    ）而
    写出于结果
                                        也。

「： 写引用于代码生成引用于代码生成。 ：」
低级虚拟机单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化（字符串合爻合表达式）列而「：待变换式：」
             字符串「：编译模块的源码：」也。
低级虚拟机单个文件代码生成顶层者会先前模块路径名而会当前路径而会式而
    虑输出引用者新引用于【】而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑无者（写出于
        『@"』附（当前路径转模块全局名于当前路径）附『" = global i64* null「：换行：」』
        ）而
    虑无者（态射授以（字符串合爻合表达式）授以有于（单函数代码生成于写出于当前路径）于式）而
    虑无者编译调试打印行于『codegen_result』于（会无而『主要代码生成完成！』）而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    虑「所有引用模块路径」者移除重复于「串相等」于（ 
        「列减」于「串相等」于（
            先前模块路径名接（
                「串联」于（态射于（表达式收集元素于（会式而
                    鉴式而
                        有（式节点于（「文件引用节点」于「文件名」）于【】）则
                            （可有「文件名」）
                        或有「其他」则（可无）
                ））于（打表态射于式于（三对子取二）））
        ））于【当前路径】
    ）而
    虑无者（态射于（会路径而写出于
                    （
                        （调试写于（会无而路径））附『@"』附（当前路径转模块全局名于路径）附『" = external global i64*』）
                ）于「所有引用模块路径」）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    虑无者编译调试打印行于『codegen_result』于（会无而『全部代码生成完成！』）而
    最终输出源码
    也。 

    
「：上个是单独文件编译，我们未来版本可能会用到，不过因为性能考虑，我们优先使用整体编译：」
「： 
低级虚拟机可执行文件代码生成顶层乃化字符串而
             化（字符串合爻合表达式）列而字符串「：编译模块的源码：」也。
低级虚拟机可执行文件代码生成顶层者会当前路径而会式而
    虑输出引用者新引用于【】而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑无者（写出于
        『@"』附（当前路径转模块全局名于当前路径）附『" = global i64* null「：换行：」』
        ）而
    虑无者（态射授以（字符串合爻合表达式）授以有于（单函数代码生成于写出于当前路径）于式）而
    虑无者「添加外部调用」于『全局异常处理器』于一而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    「：写全局的模块：」
    虑无者（写出于
        『define 』附默认调用规范附『 i64* @"内部全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层"){「：换行：」』附
        『%"默认值" = call i64* @"全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层")「：换行：」』附
        『ret i64* null「：换行：」』附
        『}「：换行：」』附
        『define i64* @"entryMain"(){「：换行：」』附
        『%"全局返回值" = call 』附默认调用规范附『 i64* @"』附（当前路径转全局函数名于当前路径）附『"(i64* null, i64* null, i64* null)「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        （尾调用返回于『全局返回值』）附『「：换行：」』附
        『}』
        ）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。 ：」
低级虚拟机可执行文件代码生成顶层乃化字符串而
             化（字符串合爻合表达式）列而字符串「：编译模块的源码：」也。
低级虚拟机可执行文件代码生成顶层者会当前路径而会式而
     发生事故于『已经移除437』也。